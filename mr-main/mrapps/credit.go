package main

//
// a MR application you need to develop
// go build -buildmode=plugin credit.go
//

import (
	"cs350/mr"
	"fmt"
	"strconv"
	"strings"
)

// The map function is called once for each file of input. The first
// argument is the name of the input file, and the second is the
// file's complete contents. You should ignore the input file name,
// and look only at the contents argument. The return value is a slice
// of key/value pairs.
func Map(filename string, contents string) []mr.KeyValue {
	// your inplementation here
	/*

			// key: name of file
		  // value: content of associated file
			for record in contents:
		  if record.Year == 2023 && record.Credit_Score > 400:
		    append_to_kva(record.Agency, "1")
		  else:
		    append_to_kva(record.Agency, "0")
	*/

	kva := []mr.KeyValue{}

	// go through each record (split by \n), then check if year == 2023 and credit score > 400

	records := strings.Split(contents, "\n")
	for _, recordStr := range records {
		if len(recordStr) != 0 { //make sure not to include end of file empty string
			record := strings.Split(recordStr, ",")
			if record[0] != "User ID" { // prevent reading first row
				credit, err := strconv.Atoi(record[3])
				if err != nil {
					fmt.Println("error converting")
				}
				if record[2] == "2023" && credit > 400 {
					kva = append(kva, mr.KeyValue{record[1], "1"})
				}
			}

		}
	}

	return kva
}

// The reduce function is called once for each key generated by the
// map tasks, with a list of all the values created for that key by
// any map task.
func Reduce(key string, values []string) string {
	// your inplementation here
	/*
			reduce(String key, Iterator values):
		  // key: an agency
		  // values: list of counts, either 0 or 1
		  int acc = 0;
		  for each v in values:
		    acc += ParseInt(v);
		  Emit(AsString(acc))

	*/
	// have no 0's, so length is fine

	return strconv.Itoa(len(values))

}
